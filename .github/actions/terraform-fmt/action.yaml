name: Terraform Formatting
description: Fix formatting and document changes and commit back to the branch

inputs:
  github-token:
    description: GitHub token to authenticate to the GitHub REST API from the host repo
    required: true

runs:
  using: composite 
  steps:
    - name: Set Diff Readme recursive
      id: find_readme
      shell: bash
      run: |
        # Stash a list of all readmes found and their sha
        readme_list=$(find . -print|grep -v '.git'|grep -v .terraform|grep -v .config|grep README.md)
        csv_found=''
        for readme in $readme_list; do
          # Finds only the Readme with .tf in the dir.
          directory_check=${readme:0:-9}
          has_tf=$(ls $directory_check | grep .tf | wc -l)
          if [ $has_tf -ge 0 ]; then
            echo "Readme found: $readme"
            csv_found+="$directory_check,"
          fi
        done;
        # removes final comma
        echo "csv_readme=${csv_found%,}" >> $GITHUB_OUTPUT

    - name: Update Terraform Docs
      uses: terraform-docs/gh-actions@v1.0.0
      with:
        working-dir: ${{ steps.find_readme.outputs.csv_readme }}
        output-method: inject
        git-push: false
        fails-on-diff: true

    - name: terraform fmt
      shell: bash
      run: |
        terraform fmt -recursive

    - name: terraform validate
      shell: bash
      run: |
        terraform validate

      # Use the GraphQL API to commit changes, so we get automatic commit signing
      # The REST contents API can't be used as easily because it only supports making single file commits
    - name: Commit updated files 
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        set -euo pipefail

        additions=()
        removed=()
        while IFS= read -r -d $'\0' status_line; do
            filename="${status_line:3}"
            git_status="${status_line:0:2}"

            if [ "$git_status" = "D " ]; then
                removed+=("$filename")
            else
                additions+=("$filename")
            fi
        done < <(git status --porcelain=v1 -z)

        if [ "${#additions[@]}" -eq 0 ] ; then
          echo "No files updated, skipping commit"
          exit 0
        fi

        commitMessage="chore: terraform README update and fmt"

        # for now, we ignore $removed files, but they could be handled similarly (it's just harder to send two lists of positional input files into jq)
        
        # jq's iteration over inputs will skip over files with 0 lines (empty files)

        jq \
          --null-input \
          --raw-input \
          --arg repositoryNameWithOwner "$GITHUB_REPOSITORY" \
          --arg branchName "$GITHUB_REF_NAME" \
          --arg expectedHeadOid "$GITHUB_SHA" \
          --arg commitMessage "$commitMessage" \
          '
        {
          "query": "mutation ($input: CreateCommitOnBranchInput!) { createCommitOnBranch(input: $input) { commit { url } } }",
          "variables": {
            "input": {
              "branch": {
                "repositoryNameWithOwner": $repositoryNameWithOwner,
                "branchName": $branchName
              },
              "message": {
                "headline": $commitMessage
              },
              "fileChanges": {
                "additions": [reduce inputs as $line ({}; .[input_filename] += [$line]) | map_values(join("\n")) | to_entries[] | {path: .key, contents: .value | @base64}]
              },
              "expectedHeadOid": $expectedHeadOid
            }
          }
        }' "${additions[@]}" | curl https://api.github.com/graphql \
          --silent \
          --fail-with-body \
          --oauth2-bearer "$(gh auth token)" \
          --data @-
